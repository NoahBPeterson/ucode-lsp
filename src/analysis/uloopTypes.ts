/**
 * uloop module type definitions and function signatures
 * Based on ucode/lib/uloop.c
 * 
 * The uloop module provides OpenWrt uloop event loop integration for handling
 * timers, file descriptors, processes, signals, and background tasks.
 */

import { UcodeType, UcodeDataType } from './symbolTable';

export interface UloopFunctionSignature {
  name: string;
  parameters: Array<{
    name: string;
    type: string;
    optional: boolean;
    defaultValue?: any;
  }>;
  returnType: string;
  description: string;
}

export interface UloopConstantSignature {
  name: string;
  value: string | number;
  type: string;
  description: string;
}

export const uloopFunctions: Map<string, UloopFunctionSignature> = new Map([
  ["error", {
    name: "error",
    parameters: [],
    returnType: "string | null",
    description: "Retrieves the last error message generated by the uloop event loop. Returns null if no error occurred."
  }],
  ["init", {
    name: "init",
    parameters: [],
    returnType: "boolean | null",
    description: "Initializes the uloop event loop, allowing subsequent usage of uloop functionalities. Returns true on success, null on error."
  }],
  ["run", {
    name: "run",
    parameters: [
      { name: "timeout", type: "integer", optional: true, defaultValue: -1 }
    ],
    returnType: "integer | null",
    description: "Runs the uloop event loop. If timeout is provided and non-negative, runs for that many milliseconds. If timeout is omitted or negative, runs indefinitely until stopped."
  }],
  ["cancelling", {
    name: "cancelling",
    parameters: [],
    returnType: "boolean",
    description: "Checks if the uloop event loop is currently shutting down. Returns true if shutting down, false otherwise."
  }],
  ["running", {
    name: "running",
    parameters: [],
    returnType: "boolean",
    description: "Checks if the uloop event loop is currently started and running. Returns true if running, false otherwise."
  }],
  ["end", {
    name: "end",
    parameters: [],
    returnType: "null",
    description: "Halts the uloop event loop, stopping its execution. Expired timeouts and already queued event callbacks are still run to completion."
  }],
  ["done", {
    name: "done",
    parameters: [],
    returnType: "null",
    description: "Stops the uloop event loop and cancels pending timeouts and events, unregisters all handles, and deallocates associated resources."
  }],
  ["timer", {
    name: "timer",
    parameters: [
      { name: "timeout", type: "integer", optional: true, defaultValue: -1 },
      { name: "callback", type: "function", optional: false }
    ],
    returnType: "uloop.timer | null",
    description: "Creates a timer instance for scheduling callbacks. Takes an optional timeout in milliseconds and a callback function to execute when the timer expires."
  }],
  ["handle", {
    name: "handle",
    parameters: [
      { name: "handle", type: "integer | fs.file | fs.proc | socket.socket", optional: false },
      { name: "callback", type: "function", optional: false },
      { name: "events", type: "integer", optional: false }
    ],
    returnType: "uloop.handle | null",
    description: "Creates a handle instance for monitoring file descriptor events. Takes a file handle, callback function, and bitwise OR-ed flags of IO events (ULOOP_READ, ULOOP_WRITE)."
  }],
  ["process", {
    name: "process",
    parameters: [
      { name: "executable", type: "string", optional: false },
      { name: "args", type: "array", optional: true },
      { name: "env", type: "object", optional: true },
      { name: "callback", type: "function", optional: false }
    ],
    returnType: "uloop.process | null",
    description: "Creates a process instance for executing external programs. Takes executable path, optional arguments array, optional environment variables, and callback function."
  }],
  ["task", {
    name: "task",
    parameters: [
      { name: "taskFunction", type: "function", optional: false },
      { name: "outputCallback", type: "function", optional: true },
      { name: "inputCallback", type: "function", optional: true }
    ],
    returnType: "uloop.task | null",
    description: "Creates a task instance for executing background tasks. Takes the task function, optional output callback, and optional input callback."
  }],
  ["interval", {
    name: "interval",
    parameters: [
      { name: "timeout", type: "integer", optional: true, defaultValue: -1 },
      { name: "callback", type: "function", optional: false }
    ],
    returnType: "uloop.interval | null",
    description: "Creates an interval instance for scheduling repeated callbacks. Takes optional interval in milliseconds and callback function to execute repeatedly."
  }],
  ["signal", {
    name: "signal",
    parameters: [
      { name: "signal", type: "string | integer", optional: false },
      { name: "callback", type: "function", optional: false }
    ],
    returnType: "uloop.signal | null",
    description: "Creates a signal instance for handling Unix signals. Takes signal name (with or without 'SIG' prefix) or signal number, and callback function."
  }],
  ["guard", {
    name: "guard",
    parameters: [
      { name: "handler", type: "function", optional: true }
    ],
    returnType: "function | boolean | null",
    description: "Sets or gets the exception handler for uloop callbacks. If no arguments, returns current handler. If handler provided, sets it and returns true."
  }]
]);

export const uloopConstants: Map<string, UloopConstantSignature> = new Map([
  // Event Mode Constants
  ["ULOOP_READ", { name: "ULOOP_READ", value: 1, type: "integer", description: "File or socket is readable - used with handle() to monitor read events" }],
  ["ULOOP_WRITE", { name: "ULOOP_WRITE", value: 2, type: "integer", description: "File or socket is writable - used with handle() to monitor write events" }],
  ["ULOOP_EDGE_TRIGGER", { name: "ULOOP_EDGE_TRIGGER", value: 4, type: "integer", description: "Enable edge-triggered event mode - used with handle() for edge-triggered notifications" }],
  ["ULOOP_BLOCKING", { name: "ULOOP_BLOCKING", value: 8, type: "integer", description: "Do not make descriptor non-blocking - used with handle() to keep descriptor in blocking mode" }]
]);

export class UloopTypeRegistry {
  getFunctionNames(): string[] {
    return Array.from(uloopFunctions.keys());
  }

  getFunction(name: string): UloopFunctionSignature | undefined {
    return uloopFunctions.get(name);
  }

  isUloopFunction(name: string): boolean {
    return uloopFunctions.has(name);
  }

  getConstantNames(): string[] {
    return Array.from(uloopConstants.keys());
  }

  getConstant(name: string): UloopConstantSignature | undefined {
    return uloopConstants.get(name);
  }

  isUloopConstant(name: string): boolean {
    return uloopConstants.has(name);
  }

  formatFunctionSignature(name: string): string {
    const func = this.getFunction(name);
    if (!func) return '';
    
    const params = func.parameters.map(p => {
      if (p.optional && p.defaultValue !== undefined) {
        return `[${p.name}: ${p.type}] = ${p.defaultValue}`;
      } else if (p.optional) {
        return `[${p.name}: ${p.type}]`;
      } else {
        return `${p.name}: ${p.type}`;
      }
    }).join(', ');
    
    return `${name}(${params}): ${func.returnType}`;
  }

  getFunctionDocumentation(name: string): string {
    const func = this.getFunction(name);
    if (!func) return '';
    
    const signature = this.formatFunctionSignature(name);
    let doc = `**${signature}**\n\n${func.description}\n\n`;
    
    if (func.parameters.length > 0) {
      doc += '**Parameters:**\n';
      func.parameters.forEach(param => {
        const optional = param.optional ? ' (optional)' : '';
        const defaultVal = param.defaultValue !== undefined ? ` (default: ${param.defaultValue})` : '';
        doc += `- \`${param.name}\` (${param.type}${optional}${defaultVal})\n`;
      });
      doc += '\n';
    }
    
    doc += `**Returns:** \`${func.returnType}\`\n\n`;
    
    // Add usage examples
    if (name === 'init') {
      doc += '**Example:**\n```ucode\n// Initialize the uloop event loop\nif (init())\n  printf("uloop initialized successfully\\n");\nelse\n  die(`Initialization failed: ${error()}\\n`);\n```';
    } else if (name === 'timer') {
      doc += '**Example:**\n```ucode\n// Create a timer that fires after 1000ms\nlet myTimer = timer(1000, () => {\n  printf("Timer expired!\\n");\n});\n```';
    } else if (name === 'handle') {
      doc += '**Example:**\n```ucode\n// Monitor a file descriptor for read events\nlet myHandle = handle(3, (events) => {\n  if (events & ULOOP_READ)\n    printf("Data ready to read!\\n");\n}, ULOOP_READ);\n```';
    } else if (name === 'run') {
      doc += '**Example:**\n```ucode\n// Run event loop for 5 seconds\nrun(5000);\n\n// Run event loop indefinitely\nrun();\n```';
    }
    
    return doc;
  }

  getConstantDocumentation(name: string): string {
    const constant = this.getConstant(name);
    if (!constant) return '';
    
    return `**${constant.name}** = \`${constant.value}\`\n\n*${constant.type}*\n\n${constant.description}`;
  }

  // Import validation methods
  isValidImport(name: string): boolean {
    return this.isUloopFunction(name) || this.isUloopConstant(name);
  }

  getValidImports(): string[] {
    return [...this.getFunctionNames(), ...this.getConstantNames()];
  }
}

export const uloopTypeRegistry = new UloopTypeRegistry();

// ============================================================================
// Uloop Object Types (timer, handle, process, task, interval, signal, pipe)
// ============================================================================

export enum UloopObjectType {
  ULOOP_TIMER = 'uloop.timer',
  ULOOP_HANDLE = 'uloop.handle',
  ULOOP_PROCESS = 'uloop.process',
  ULOOP_TASK = 'uloop.task',
  ULOOP_INTERVAL = 'uloop.interval',
  ULOOP_SIGNAL = 'uloop.signal',
  ULOOP_PIPE = 'uloop.pipe'
}

export interface UloopObjectDefinition {
  type: UloopObjectType;
  methods: Map<string, UloopFunctionSignature>;
}

export class UloopObjectRegistry {
  private static instance: UloopObjectRegistry;
  private types: Map<UloopObjectType, UloopObjectDefinition> = new Map();

  private constructor() {
    this.initializeUloopObjectTypes();
  }

  public static getInstance(): UloopObjectRegistry {
    if (!UloopObjectRegistry.instance) {
      UloopObjectRegistry.instance = new UloopObjectRegistry();
    }
    return UloopObjectRegistry.instance;
  }

  private initializeUloopObjectTypes(): void {
    // Timer methods
    const timerMethods = new Map<string, UloopFunctionSignature>([
      ['set', {
        name: 'set',
        parameters: [
          { name: 'timeout', type: 'integer', optional: true, defaultValue: -1 }
        ],
        returnType: 'boolean | null',
        description: 'Rearms the uloop timer with the specified timeout in milliseconds. Returns true on success, null on error.'
      }],
      ['remaining', {
        name: 'remaining',
        parameters: [],
        returnType: 'integer',
        description: 'Returns the number of milliseconds until the timer expires, or -1 if the timer is not armed.'
      }],
      ['cancel', {
        name: 'cancel',
        parameters: [],
        returnType: 'boolean',
        description: 'Cancels the uloop timer, disarming it and removing it from the event loop. Returns true on success.'
      }]
    ]);

    // Handle methods
    const handleMethods = new Map<string, UloopFunctionSignature>([
      ['fileno', {
        name: 'fileno',
        parameters: [],
        returnType: 'integer',
        description: 'Returns the file descriptor number associated with the handle.'
      }],
      ['handle', {
        name: 'handle',
        parameters: [],
        returnType: 'fs.file | fs.proc | socket.socket',
        description: 'Returns the underlying file or socket instance associated with the uloop handle.'
      }],
      ['delete', {
        name: 'delete',
        parameters: [],
        returnType: 'null',
        description: 'Unregisters the uloop handle from the event loop and frees associated resources.'
      }]
    ]);

    // Process methods
    const processMethods = new Map<string, UloopFunctionSignature>([
      ['pid', {
        name: 'pid',
        parameters: [],
        returnType: 'integer',
        description: 'Returns the process ID (PID) of the operating system process launched by process().'
      }],
      ['delete', {
        name: 'delete',
        parameters: [],
        returnType: 'boolean',
        description: 'Unregisters the process from the uloop event loop and releases associated resources. Returns true on success.'
      }]
    ]);

    // Task methods
    const taskMethods = new Map<string, UloopFunctionSignature>([
      ['pid', {
        name: 'pid',
        parameters: [],
        returnType: 'integer',
        description: 'Returns the process ID (PID) of the underlying forked process launched by task().'
      }],
      ['kill', {
        name: 'kill',
        parameters: [],
        returnType: 'boolean | null',
        description: 'Terminates the task process by sending SIGTERM. Returns true on success, null on error.'
      }],
      ['finished', {
        name: 'finished',
        parameters: [],
        returnType: 'boolean',
        description: 'Checks if the task function has already run to completion. Returns true if finished, false otherwise.'
      }]
    ]);

    // Interval methods
    const intervalMethods = new Map<string, UloopFunctionSignature>([
      ['set', {
        name: 'set',
        parameters: [
          { name: 'interval', type: 'integer', optional: true, defaultValue: -1 }
        ],
        returnType: 'boolean | null',
        description: 'Rearms the uloop interval with the specified interval in milliseconds. Returns true on success, null on error.'
      }],
      ['remaining', {
        name: 'remaining',
        parameters: [],
        returnType: 'integer',
        description: 'Returns the milliseconds until the next expiration of the interval, or -1 if not armed.'
      }],
      ['expirations', {
        name: 'expirations',
        parameters: [],
        returnType: 'integer',
        description: 'Returns the number of times the interval timer has expired (fired) since instantiation.'
      }],
      ['cancel', {
        name: 'cancel',
        parameters: [],
        returnType: 'boolean',
        description: 'Cancels the uloop interval, disarming it and removing it from the event loop. Returns true on success.'
      }]
    ]);

    // Signal methods
    const signalMethods = new Map<string, UloopFunctionSignature>([
      ['signo', {
        name: 'signo',
        parameters: [],
        returnType: 'integer',
        description: 'Returns the signal number that this uloop signal handler is configured to respond to.'
      }],
      ['delete', {
        name: 'delete',
        parameters: [],
        returnType: 'boolean',
        description: 'Uninstalls the signal handler, restoring the previous or default handler for the signal. Returns true on success.'
      }]
    ]);

    // Pipe methods (used inside task functions)
    const pipeMethods = new Map<string, UloopFunctionSignature>([
      ['send', {
        name: 'send',
        parameters: [
          { name: 'msg', type: 'any', optional: false }
        ],
        returnType: 'boolean | null',
        description: 'Sends a serialized message to the task handle. Returns true on success, null on error.'
      }],
      ['receive', {
        name: 'receive',
        parameters: [],
        returnType: 'any | null',
        description: 'Reads input from the task communication pipe. Returns the deserialized message or null on error.'
      }],
      ['sending', {
        name: 'sending',
        parameters: [],
        returnType: 'boolean',
        description: 'Checks if the remote task handle has an input callback registered. Returns true if available, false otherwise.'
      }],
      ['receiving', {
        name: 'receiving',
        parameters: [],
        returnType: 'boolean',
        description: 'Checks if the task handle has an output callback registered. Returns true if available, false otherwise.'
      }]
    ]);

    // Register all object types
    this.types.set(UloopObjectType.ULOOP_TIMER, {
      type: UloopObjectType.ULOOP_TIMER,
      methods: timerMethods
    });

    this.types.set(UloopObjectType.ULOOP_HANDLE, {
      type: UloopObjectType.ULOOP_HANDLE,
      methods: handleMethods
    });

    this.types.set(UloopObjectType.ULOOP_PROCESS, {
      type: UloopObjectType.ULOOP_PROCESS,
      methods: processMethods
    });

    this.types.set(UloopObjectType.ULOOP_TASK, {
      type: UloopObjectType.ULOOP_TASK,
      methods: taskMethods
    });

    this.types.set(UloopObjectType.ULOOP_INTERVAL, {
      type: UloopObjectType.ULOOP_INTERVAL,
      methods: intervalMethods
    });

    this.types.set(UloopObjectType.ULOOP_SIGNAL, {
      type: UloopObjectType.ULOOP_SIGNAL,
      methods: signalMethods
    });

    this.types.set(UloopObjectType.ULOOP_PIPE, {
      type: UloopObjectType.ULOOP_PIPE,
      methods: pipeMethods
    });
  }

  public getUloopType(typeName: string): UloopObjectDefinition | undefined {
    return this.types.get(typeName as UloopObjectType);
  }

  public isUloopType(typeName: string): boolean {
    return this.types.has(typeName as UloopObjectType);
  }

  public getUloopMethod(typeName: string, methodName: string): UloopFunctionSignature | undefined {
    const uloopType = this.getUloopType(typeName);
    return uloopType?.methods.get(methodName);
  }

  public getMethodsForType(typeName: string): string[] {
    const uloopType = this.getUloopType(typeName);
    return uloopType ? Array.from(uloopType.methods.keys()) : [];
  }

  // Check if a variable type represents a uloop object
  public isVariableOfUloopType(dataType: any): UloopObjectType | null {
    if (typeof dataType === 'string') {
      return null;
    }
    
    // Check if it's a module type with uloop object type name
    if ('moduleName' in dataType && typeof dataType.moduleName === 'string') {
      const moduleName = dataType.moduleName;
      if (this.isUloopType(moduleName)) {
        return moduleName as UloopObjectType;
      }
    }

    return null;
  }
}

// Singleton instance
export const uloopObjectRegistry = UloopObjectRegistry.getInstance();

// Helper functions for type checking
export function isUloopObjectType(typeName: string): typeName is UloopObjectType {
  return Object.values(UloopObjectType).includes(typeName as UloopObjectType);
}

export function createUloopObjectDataType(uloopType: UloopObjectType): UcodeDataType {
  return {
    type: UcodeType.OBJECT,
    moduleName: uloopType
  };
}